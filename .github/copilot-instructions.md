# EduVote AI Assistant Guide

- **Project type**: PyQt6 desktop app with a light MVC split (`Views/`, `Controller/`, `Models/`). Entry is `main.py`; it builds a `QApplication`, shows `Views.views_login.LoginView`, and routes to student `Views.main_window.MainWindow` or `Views.admin.AdminMainWindow` via `Controller/controller_login.py`.
- **Runtime**: Use the venv in `.venv/`; typical launch: `C:/Pycharms/.venv/Scripts/python.exe main.py` from the repo root. Requires MySQL reachable with creds from `config.py` (`DB_CONFIG`).
- **Database layer**: All DB access goes through `Models/model_db.py`. It bootstraps schema (users, elections, candidates, voting_records, sections) and adds missing columns/FKs idempotently. Passwords are SHA-256 hashed. Prefer its helpers (e.g., `get_user_allowed_elections`, `get_candidates_for_election`, `has_user_voted`, `update_user_profile`) rather than ad-hoc queries.
- **Voting data model**: Authoritative vote counts come from `voting_records` (one per user/election, optional `candidate_id`, `status`, `voted_at`). The legacy `candidates.vote_count` is a fallback only; admin dashboards aggregate with `COUNT(*)` over `voting_records`. Preserve the COALESCE/COUNT patterns when changing queries.
- **Student UI flows**: `Views/main_window.py` wires sidebar pages: `DashboardPage`, `HistoryPage`, `CandidatesPage`, `ResultsPage`. It loads allowed elections via `Database.get_user_allowed_elections`, fetches candidates per election, and checks `has_user_voted` to drive UI state. Profile editing dialog uses `Database.update_user_profile` with uniqueness checks; keep messages user-friendly.
- **Admin UI flows**: `Views/admin/` holds admin dashboards/results/components. `admin_results.py` and `admin_dashboard.py` both aggregate votes from `voting_records`; totals are cast to `int` before chart/table use. `admin_components.py` defines reusable `BarChart`, `PieChart`, `DataTable`, `WinnerBanner`, etc.—reuse these instead of re-styling widgets.
- **Controllers**: `controller_login.py` handles authentication via `Database.authenticate_user`, branches on `role`, and keeps dashboard references to avoid GC. Signup is intentionally disabled (login controller passes `signup_view=None`).
- **Styling/components**: Shared student components live in `Views/components.py`; admin components in `Views/admin/admin_components.py`. UI uses Segoe UI fonts, light palette, and custom widgets (badges, cards, progress bars). Respect existing style sheets when adding widgets.
- **Data access conventions**: Every DB method opens a new connection and closes it; mirror that pattern. Validation favors graceful user messages (e.g., missing fields, uniqueness). When returning vote data, normalize numeric types (`int(...)`) to avoid Decimal/str issues in PyQt widgets.
- **Utilities**: `fix_db.py` is a one-off helper to inspect/patch the `users` table (adds `email` column if missing). Avoid running it in normal flows.
- **Testing/debug**: No test suite present. Validate changes by launching the app and exercising student/admin dashboards. Watch console for MySQL connector errors.
- **Common pitfalls**: Ensure MySQL is running with the configured creds; empty passwords in `config.py` will fail on secured setups. Remember `voting_records` has a unique constraint per user/election—enforce this when writing vote logic. Keep UI responsive by avoiding long DB work on the UI thread (consider light queries only).

If anything here seems incomplete or you need more workflows documented, let me know what to add or clarify.
